### 一、函数基础  
函数就是将一些语句组合在一起的组件，从而让他们能够不止一次的在程序中运行。
1. 定义函数
```
def name(arg1, arg2, ......argN):
    statements
```
def的头部定义了被赋值函数对象的函数名，并在圆括号中包含了0个或者以上的参数（有时候称为形式参数，简称形参）。在函数调用的时候，括号中传入的对象将赋值给头部的形式参数。函数体通常包含一条return语句：
```
def name(arg1,arg2,......,argN):
    ...
    return value
```
return 语句可以出现在函数体的任何地方，当return 被调用的时候，它将结束函数的调用并将结果返回至函数调用处。如果没有return语句，那么函数将在控制流执行完函数时结束，并自动返回了None对象。  
python的def语句是一条真正可执行的语句：当它运行的时候会创建一个新的函数对象并将其赋值给一个变量名。因为函数是在运行时才定义的，所以函数名并没有什么特别之处。关键在于函数名所引用的那个对象：
```
def func():
    print("python")
othername = func #这里，函数被赋值给一个不同的变量名，并通过新的变量名进行调用。
othername()
```
**第一个示例：定义和调用**   
函数主要包括两个方面：定义（def创建了一个函数）以及调用（表达式告诉python去运行函数体）  
定义函数：
```
def times(x,y):
    return x * y
```
当python运行到这里并执行def语句后，它将创建一个新的函数对象来封装这个函数的代码并将这个对象赋值给变量名tiems。
调用函数：
```
value = times(2,4)
print(value)
# 8
```
----
```
value = times('Ni',4)
print(value)
# 'NiNiNiNi'
```
同样的函数，在一个实例下执行的是乘法，在另一实例下执行的却是重复。python把对某一对象在某种语法下的合理性交给那个对象自身来判断，这种行为就被称为多态。
### 二、函数——作用域  
在源代码中变量名被赋值的位置决定了这个变量名能被访问到的范围，就是作用域。  
+ 在def内赋值的变量名只能够在def内的代码使用。不能在函数的外部引用该变量名。
+ 在def内赋值的变量与def外赋值的变量名并不冲突，即使是相同的变量名。在def外被赋值的变量民X和在def内赋值的变量名X是两个完全不同的变量。
+ 在任何情况下，一个变量的作用域总是由它在代码中被赋值的位置决定的，而与函数调用无关。
变量可以在3个不同的地方赋值，分别对应三种不同的作用域：
- 如果一个变量在def内赋值，它对该函数而言是局部的
- 如果一个变量在一个外层的def中赋值，对于内层函数来说，它是非局部的。
- 如果一个变量在所有的def外赋值，它对整个文件来说是全局的。
例如：
```
X = 99      #创建一个名为X的全局变量
def func():
    X = 88 #创建一个名为X的局部变量
```
**注意：** 要注意原位置改变对象并不会把变量划分为局部变量，实际上只有对变量名赋值才可以。例如，如果变量名L在模块的顶层被赋值为一个列表，在一个函数内类似L.append(X),这样的语句并不会将L划分为局部变量，而L = X却可以。  
1. 变量名解析：LEGB规则  
当你在函数中使用未限定的变量名时，python将查找4个作用域并在第一次找到该变量名的地方停下来：首先是局部作用域（L），其次是向外一层的def或者lambda的局部作用域（E），之后是全局作用域（G），最后是内置作用域（B）。如果没有找到，就会报错。  
作用域实例：
```
X = 99
def func(Y):
  Z = X + Y
  return Z
func(1)
```
全局变量名：X，func
因为X是在模块文件顶层赋值的，所以它是全局变量；它能够在函数内部作为一个简单的未限定变量进行引用而不需要特意声明为全局变量。def语句在这个模块文件顶层将一个函数对象赋值给了变量名func，因此func也是全局变量。
局部变量名：Y, Z
Y和Z都是在函数定义内部进行赋值的：Z是通过=语句赋值的，而Y是由于参数总是通过赋值来进行传递的。  
2. global 语句
global语句告诉python函数计划生成一个或者多个全局变量名——存在于整个模块内部作用域的变量名。global语句包含了关键字global，其后跟着一个或者多个由逗号分开的变量名。当在函数主体被赋值或者引用的时，所列出的变量名将被映射到整个模块的作用域内。
+ 全局变量是在外层模块文件的顶层被赋值的变量名。
+ 全局变量如果是在函数内被赋值的话，必须经过global声明。
+ 全局变量名在函数内部不经过声明也可以被引用。
```
x = 88
def func():
    global x
    x = 99

func()
print(x)
```
3. 作用域和嵌套函数
嵌套的函数作用域查找规则
一个 **引用（X）** 首先在局部（函数内）作用域查找变量名X；之后会在代码句法上的外层函数的局部作用域，从内到外查找；之后查找当前的全局作用域（模块文件），最后查找内置作用域（模块builtins）。然而global声明会直接从全局（模块文件）作用域进行查找。在默认情况下，一个 **赋值（X=value）** 会创建或改变当前作用域的变量名X。如果X在函数内部声明为全局变量，它会创建或者改变整个模块的作用域中变量名X。
```
X = 99
def f1():
    X = 88
    def f2():
        print(X)
    f2()
f1()
```
代码解析：  
def 是一个间的可执行语句，可以出现在任意其他语句能够出现的地方，包括嵌套在另一个def中。这里，嵌套的def在函数f1调用时运行；这个def将生成一个函数，将其赋值给变量f2，f2是f1的局部作用域内的一个局部变量。可以说，f2是一个临时函数，仅在f1内部执行的过程中存在。  
f2内部当打印变量X时，X引用了存在与外层函数f1的局部作用域内的X的值。因为函数能够访问在物理上处于外层def声明的变量名，通过LEGB查找规则，f2内的X自动映射为f1中的x。  
这种嵌套作用域查找即便在外层函数已经返回后也是有效的。例如，下面的代码定义一个函数，该函数创建并返回另外一个函数：
```
def f1():
    X = 88
    def f2():
        print(X)
    return f2
action = f1()
action()
# 88
```
当调用action()时，f1已经不处于激活状态，但f2记住了f1嵌套作用域中的X。
4. 工厂函数：闭包
一个函数用来创建并返回另外一个函数，而被创建的函数彼此之间可能带有不同的信息。
```
def maker(N):
    def action(X):
        return x ** N
    return action

f = maker(2)
f(3)
# 9
f(4)
# 16
```
这里虽然在调用action时maker已经返回并退出，但是内嵌的函数记住了整数2，即maker内部变量N的值，实际上在外层嵌套作用域内的N被作为执行的状态信息被保留下来，并附加到生成的action函数上，这也是当它被调用时返回其平方的原因。
```
f = maker(2)
g = maker(3)
f(4)
# 16
g(4)
# 64
```
因为每次对这样的工厂函数调用，都将得到属于自己的状态信息，所以名称g的函数记住了3,而名称f函数记住了2。  
**注意：** 在没有嵌套作用域的岁月（python2.2之前的版本），需要借助默认参数从上层作用域传递值给嵌套函数。
```
def f1():
    X = 88
    def f2(X=X):
        print(X)
    f2()
f1()
```
----
```
def func():
    x = 4
    action = (lambda n, x=x: x ** n)
    return action
```
5. 循环变量可能需要默认参数值，而不是作用域  
问题:如果在函数中定义的def或者lambda嵌套在一个循环中，而这个嵌套函数又引用了一个外层作用于的变量，该变量被循环所改变，那么所有在这个循环中产生的函数会有相同的值——也就是最后一次循环完成时被引用的变量的值。
```
>>> def makeActions():
...     acts = []
...     for i in range(5):
...         acts.append(lambda x: i ** x)
...     return acts
...
>>> acts = makeActions()
>>> acts[0](2)
16
>>> acts[1](2)
16
>>> acts[2](2)
16
>>> acts[3](2)
16
>>> acts[4](2)
16
```
原因：因为外层作用域中的变量在嵌套的函数调用时才进行查找，所以它们实际记住的是同样的值，也就是最后一次循环迭代中循环变量的值。即每个函数的结果都是i=4，就是4的平方16。  
上述是唯一一种还需要动态默认值参数来显式保持外层作用域中值的情况，而不是简单的外层作用域的引用。
```
>>> def makeActions():
...     acts = []
...     for i in range(5):
...         acts.append(lambda x,i=i: i ** x)
...     return acts
...
>>> acts = makeActions()
>>> acts[0](2)
0
>>> acts[1](2)
1
>>> acts[2](2)
4
>>> acts[3](2)
9
>>> acts[4](2)
16
```
为了让这类代码工作，必须使用默认参数传入当前作用域中的值。因为默认参数的求值实在嵌套函数创建的时候就发生的（而不是函数调用时），所以每个函数记住了属于自己的变量i的值。
6. nonlocal语句
在内嵌的def中用nonlocal声明变量，就可以对外层的函数中的名称进行读取和写入访问。和global的不同之处在于nonlocal作用于外层函数的作用域的一个名称，而不是多有def之外的全局作用域；而且在声明nonlocal名称的时候，它必须已经存在于该外层函数的作用域中，而global不需要。
```
>>> def tester(start):
...     state = start
...     def nested(label):
...         print(label,state)
...     return nested
...
>>> F = tester(0)
>>> F('spam')
spam 0
```
默认不允许修改def作用域的名称
```
>>> def tester(start):
...     state = start
...     def nested(label):
...         print(label,start)
...         state += 1
...     return nested
...
>>> F = tester(0)
>>> F('spam')
spam 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in nested
UnboundLocalError: local variable 'state' referenced before assignment
```
使用nonlocal进行修改
```
>>> def tester(start):
...     state = start
...     def nested(label):
...         nonlocal state
...         print(label,state)
...         state += 1
...     return nested
>>> F = tester(0)
>>> F('spam')
spam 0
>>> F('ham')
ham 1
>>> F('eggs')
eggs 2
```
多次调用tester工厂函数，以便在内存中获取其状态多个副本。外层作用域的state对象本质上被附加到返回的nested函数对象中，每次调用都产生一个新的state对象，从而不会影响到其他的。
```
>>> G = teser(30)
>>> G('spam')
spam 30
>>> G('ham')
ham 31
>>> G('eggs')
eggs 32
```
**注意：** nonlocal仅是使用于python3
