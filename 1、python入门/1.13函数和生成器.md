### 一、函数基础  
函数就是将一些语句组合在一起的组件，从而让他们能够不止一次的在程序中运行。
1. 定义函数
```
def name(arg1, arg2, ......argN):
    statements
```
def的头部定义了被赋值函数对象的函数名，并在圆括号中包含了0个或者以上的参数（有时候称为形式参数，简称形参）。在函数调用的时候，括号中传入的对象将赋值给头部的形式参数。函数体通常包含一条return语句：
```
def name(arg1,arg2,......,argN):
    ...
    return value
```
return 语句可以出现在函数体的任何地方，当return 被调用的时候，它将结束函数的调用并将结果返回至函数调用处。如果没有return语句，那么函数将在控制流执行完函数时结束，并自动返回了None对象。  
python的def语句是一条真正可执行的语句：当它运行的时候会创建一个新的函数对象并将其赋值给一个变量名。因为函数是在运行时才定义的，所以函数名并没有什么特别之处。关键在于函数名所引用的那个对象：
```
def func():
    print("python")
othername = func #这里，函数被赋值给一个不同的变量名，并通过新的变量名进行调用。
othername()
```
**第一个示例：定义和调用**
函数主要包括两个方面：定义（def创建了一个函数）以及调用（表达式告诉python去运行函数体）  
定义函数：
```
def times(x,y):
    return x * y
```
当python运行到这里并执行def语句后，它将创建一个新的函数对象来封装这个函数的代码并将这个对象赋值给变量名tiems。
调用函数：
```
value = times(2,4)
print(value)
# 8
```
----
```
value = times('Ni',4)
print(value)
# 'NiNiNiNi'
```
同样的函数，在一个实例下执行的是乘法，在另一实例下执行的却是重复。python把对某一对象在某种语法下的合理性交给那个对象自身来判断，这种行为就被称为多态。
### 二、函数——作用域  
在源代码中变量名被赋值的位置决定了这个变量名能被访问到的范围，就是作用域。  
+ 在def内赋值的变量名只能够在def内的代码使用。不能在函数的外部引用该变量名。
+ 在def内赋值的变量与def外赋值的变量名并不冲突，即使是相同的变量名。在def外被赋值的变量民X和在def内赋值的变量名X是两个完全不同的变量。
+ 在任何情况下，一个变量的作用域总是由它在代码中被赋值的位置决定的，而与函数调用无关。
 变量可以在3个不同的地方赋值，分别对应三种不同的作用域：
 - 如果一个变量在def内赋值，它对该函数而言是局部的
 - 如果一个变量在一个外层的def中赋值，对于内层函数来说，它是非局部的。
 - 如果一个变量在所有的def外赋值，它对整个文件来说是全局的。
例如：
 ```
 X = 99      #创建一个名为X的全局变量
 def func():
      X = 88 #创建一个名为X的局部变量
 ```
 **注意：** 要注意原位置改变对象并不会把变量划分为局部变量，实际上只有对变量名赋值才可以。例如，如果变量名L在模块的顶层被赋值为一个列表，在一个函数内类似L.append(X),这样的语句并不会将L划分为局部变量，而L = X却可以。  
 1. 变量名解析：LEGB规则  
 当你在函数中使用未限定的变量名时，python将查找4个作用域并在第一次找到该变量名的地方停下来：首先是局部作用域（L），其次是向外一层的def或者lambda的局部作用域（E），之后是全局作用域（G），最后是内置作用域（B）。如果没有找到，就会报错。  
 **作用域实例**  
 ```
 X = 99
 def func(Y):
    Z = X + Y
    return Z
func(1)
 ```
全局变量名：X，func
因为X是在模块文件顶层赋值的，所以它是全局变量；它能够在函数内部作为一个简单的未限定变量进行引用而不需要特意声明为全局变量。def语句在这个模块文件顶层将一个函数对象赋值给了变量名func，因此func也是全局变量。
局部变量名：Y, Z
Y和Z都是在函数定义内部进行赋值的：Z是通过=语句赋值的，而Y是由于参数总是通过赋值来进行传递的。
